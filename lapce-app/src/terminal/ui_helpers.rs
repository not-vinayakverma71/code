// Terminal Pre-IPC: UI helpers for displaying terminal metadata
// Part of HP-UI-1: UI Integration feature

use std::time::Duration;
use serde::{Serialize, Deserialize};

use super::types::{CommandSource, CommandRecord};
use super::persistence::TerminalSnapshot;
use super::restore::{RestoreSession, SnapshotSummary};

/// Badge configuration for command source display
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CommandSourceBadge {
    /// Display label (e.g., "USER", "AI")
    pub label: String,
    
    /// Color theme (for UI styling)
    pub color: BadgeColor,
    
    /// Tooltip text
    pub tooltip: String,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum BadgeColor {
    /// User-generated commands (blue/neutral)
    User,
    
    /// AI-generated commands (purple/accent)
    Cascade,
    
    /// Warning/error state (yellow/red)
    Warning,
}

impl CommandSourceBadge {
    /// Create badge for command source
    pub fn from_source(source: CommandSource) -> Self {
        match source {
            CommandSource::User => Self {
                label: "USER".to_string(),
                color: BadgeColor::User,
                tooltip: "Command entered by user".to_string(),
            },
            CommandSource::Cascade => Self {
                label: "AI".to_string(),
                color: BadgeColor::Cascade,
                tooltip: "Command generated by Cascade AI".to_string(),
            },
        }
    }
    
    /// Create badge with custom label
    pub fn with_label(mut self, label: impl Into<String>) -> Self {
        self.label = label.into();
        self
    }
    
    /// Create badge with custom tooltip
    pub fn with_tooltip(mut self, tooltip: impl Into<String>) -> Self {
        self.tooltip = tooltip.into();
        self
    }
}

/// Forced exit indicator for UI display
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct ForcedExitIndicator {
    /// Display message
    pub message: String,
    
    /// Whether to show warning icon
    pub show_warning: bool,
    
    /// Command duration before force-exit
    pub duration: Option<String>,
}

impl ForcedExitIndicator {
    /// Create from command record
    pub fn from_record(record: &CommandRecord) -> Option<Self> {
        if !record.forced_exit {
            return None;
        }
        
        let duration_str = if record.duration_ms > 0 {
            Self::format_duration(Duration::from_millis(record.duration_ms))
        } else {
            "unknown".to_string()
        };
        
        Some(Self {
            message: format!("Command force-completed after {}", duration_str),
            show_warning: true,
            duration: Some(duration_str),
        })
    }
    
    /// Format duration for display
    fn format_duration(duration: Duration) -> String {
        let secs = duration.as_secs();
        if secs < 60 {
            format!("{}s", secs)
        } else if secs < 3600 {
            format!("{}m {}s", secs / 60, secs % 60)
        } else {
            format!("{}h {}m", secs / 3600, (secs % 3600) / 60)
        }
    }
    
    /// Get short message for compact display
    pub fn short_message(&self) -> String {
        if let Some(ref duration) = self.duration {
            format!("Forced exit ({})", duration)
        } else {
            "Forced exit".to_string()
        }
    }
}

/// Terminal header metadata for UI display
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TerminalHeaderMetadata {
    /// Terminal title
    pub title: String,
    
    /// Current working directory
    pub cwd: String,
    
    /// Last command source badge (if any)
    pub last_command_badge: Option<CommandSourceBadge>,
    
    /// Forced exit indicator (if last command was forced)
    pub forced_exit_indicator: Option<ForcedExitIndicator>,
    
    /// Command count
    pub command_count: usize,
    
    /// AI command count
    pub ai_command_count: usize,
}

impl TerminalHeaderMetadata {
    /// Create from command history
    pub fn from_history(
        title: String,
        cwd: String,
        recent_commands: &[CommandRecord],
    ) -> Self {
        let command_count = recent_commands.len();
        let ai_command_count = recent_commands
            .iter()
            .filter(|cmd| cmd.source == CommandSource::Cascade)
            .count();
        
        let last_command_badge = recent_commands
            .last()
            .map(|cmd| CommandSourceBadge::from_source(cmd.source));
        
        let forced_exit_indicator = recent_commands
            .last()
            .and_then(ForcedExitIndicator::from_record);
        
        Self {
            title,
            cwd,
            last_command_badge,
            forced_exit_indicator,
            command_count,
            ai_command_count,
        }
    }
    
    /// Check if there are any warnings to display
    pub fn has_warnings(&self) -> bool {
        self.forced_exit_indicator.is_some()
    }
}

/// Snapshot restore UI data
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnapshotRestoreUI {
    /// Total snapshots available
    pub total_snapshots: usize,
    
    /// Recent snapshots (< 24h)
    pub recent_count: usize,
    
    /// Older snapshots
    pub older_count: usize,
    
    /// Individual snapshot items for display
    pub items: Vec<SnapshotRestoreItem>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnapshotRestoreItem {
    /// Snapshot ID
    pub id: String,
    
    /// Terminal title
    pub title: String,
    
    /// Working directory
    pub cwd: String,
    
    /// Age description (e.g., "2 hours ago")
    pub age: String,
    
    /// Command count
    pub command_count: usize,
    
    /// Whether this is a recent snapshot
    pub is_recent: bool,
}

impl SnapshotRestoreUI {
    /// Create from restore session
    pub fn from_session(session: &RestoreSession) -> Self {
        let summary = session.get_snapshot_summary();
        let items = Self::create_items(&summary);
        
        Self {
            total_snapshots: summary.total,
            recent_count: summary.recent,
            older_count: summary.older,
            items,
        }
    }
    
    /// Create display items from summary
    fn create_items(summary: &SnapshotSummary) -> Vec<SnapshotRestoreItem> {
        let mut items = Vec::new();
        
        // Add recent snapshots first
        for snapshot in &summary.recent_snapshots {
            items.push(Self::create_item(snapshot, true));
        }
        
        // Then older snapshots
        for snapshot in &summary.older_snapshots {
            items.push(Self::create_item(snapshot, false));
        }
        
        items
    }
    
    /// Create a single display item
    fn create_item(snapshot: &TerminalSnapshot, is_recent: bool) -> SnapshotRestoreItem {
        SnapshotRestoreItem {
            id: snapshot.term_id.clone(),
            title: snapshot.title.clone(),
            cwd: snapshot.cwd.display().to_string(),
            age: Self::format_age(snapshot.age()),
            command_count: snapshot.command_history.len(),
            is_recent,
        }
    }
    
    /// Format age for display
    fn format_age(age: Duration) -> String {
        let secs = age.as_secs();
        
        if secs < 60 {
            "just now".to_string()
        } else if secs < 3600 {
            let mins = secs / 60;
            if mins == 1 {
                "1 minute ago".to_string()
            } else {
                format!("{} minutes ago", mins)
            }
        } else if secs < 86400 {
            let hours = secs / 3600;
            if hours == 1 {
                "1 hour ago".to_string()
            } else {
                format!("{} hours ago", hours)
            }
        } else {
            let days = secs / 86400;
            if days == 1 {
                "1 day ago".to_string()
            } else {
                format!("{} days ago", days)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    
    #[test]
    fn test_command_source_badge_user() {
        let badge = CommandSourceBadge::from_source(CommandSource::User);
        
        assert_eq!(badge.label, "USER");
        assert_eq!(badge.color, BadgeColor::User);
        assert!(badge.tooltip.contains("user"));
    }
    
    #[test]
    fn test_command_source_badge_cascade() {
        let badge = CommandSourceBadge::from_source(CommandSource::Cascade);
        
        assert_eq!(badge.label, "AI");
        assert_eq!(badge.color, BadgeColor::Cascade);
        assert!(badge.tooltip.contains("Cascade"));
    }
    
    #[test]
    fn test_badge_customization() {
        let badge = CommandSourceBadge::from_source(CommandSource::User)
            .with_label("CUSTOM")
            .with_tooltip("Custom tooltip");
        
        assert_eq!(badge.label, "CUSTOM");
        assert_eq!(badge.tooltip, "Custom tooltip");
    }
    
    #[test]
    fn test_forced_exit_indicator() {
        let mut record = CommandRecord::new(
            "sleep 10".to_string(),
            CommandSource::User,
            PathBuf::from("/tmp"),
        );
        record.forced_exit = true;
        record.duration_ms = 3000;
        
        let indicator = ForcedExitIndicator::from_record(&record).unwrap();
        
        assert!(indicator.show_warning);
        assert!(indicator.message.contains("force-completed"));
        assert_eq!(indicator.short_message(), "Forced exit (3s)");
    }
    
    #[test]
    fn test_forced_exit_indicator_none_when_not_forced() {
        let record = CommandRecord::new(
            "ls".to_string(),
            CommandSource::User,
            PathBuf::from("/tmp"),
        );
        
        assert!(ForcedExitIndicator::from_record(&record).is_none());
    }
    
    #[test]
    fn test_duration_formatting() {
        assert_eq!(
            ForcedExitIndicator::format_duration(Duration::from_secs(45)),
            "45s"
        );
        
        assert_eq!(
            ForcedExitIndicator::format_duration(Duration::from_secs(90)),
            "1m 30s"
        );
        
        assert_eq!(
            ForcedExitIndicator::format_duration(Duration::from_secs(3665)),
            "1h 1m"
        );
    }
    
    #[test]
    fn test_terminal_header_metadata() {
        let mut commands = Vec::new();
        commands.push(CommandRecord::new(
            "ls".to_string(),
            CommandSource::User,
            PathBuf::from("/tmp"),
        ));
        commands.push(CommandRecord::new(
            "pwd".to_string(),
            CommandSource::Cascade,
            PathBuf::from("/tmp"),
        ));
        
        let metadata = TerminalHeaderMetadata::from_history(
            "Test Terminal".to_string(),
            "/tmp".to_string(),
            &commands,
        );
        
        assert_eq!(metadata.command_count, 2);
        assert_eq!(metadata.ai_command_count, 1);
        assert!(metadata.last_command_badge.is_some());
        assert_eq!(
            metadata.last_command_badge.unwrap().color,
            BadgeColor::Cascade
        );
    }
    
    #[test]
    fn test_terminal_header_has_warnings() {
        let mut commands = Vec::new();
        let mut record = CommandRecord::new(
            "sleep 10".to_string(),
            CommandSource::User,
            PathBuf::from("/tmp"),
        );
        record.forced_exit = true;
        commands.push(record);
        
        let metadata = TerminalHeaderMetadata::from_history(
            "Test".to_string(),
            "/tmp".to_string(),
            &commands,
        );
        
        assert!(metadata.has_warnings());
    }
    
    #[test]
    fn test_age_formatting() {
        assert_eq!(
            SnapshotRestoreUI::format_age(Duration::from_secs(30)),
            "just now"
        );
        
        assert_eq!(
            SnapshotRestoreUI::format_age(Duration::from_secs(120)),
            "2 minutes ago"
        );
        
        assert_eq!(
            SnapshotRestoreUI::format_age(Duration::from_secs(7200)),
            "2 hours ago"
        );
        
        assert_eq!(
            SnapshotRestoreUI::format_age(Duration::from_secs(172800)),
            "2 days ago"
        );
    }
    
    #[test]
    fn test_badge_serialization() {
        let badge = CommandSourceBadge::from_source(CommandSource::Cascade);
        let json = serde_json::to_string(&badge).unwrap();
        
        assert!(json.contains("\"label\":\"AI\""));
        assert!(json.contains("\"color\":\"cascade\""));
        
        let deserialized: CommandSourceBadge = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, badge);
    }
}
