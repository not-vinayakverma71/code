use std::sync::Arc;
use async_trait::async_trait;
use serde_json::{json, Value};
use anyhow::Result;
//use git2;

use crate::mcp_tools::core::{Tool, ToolContext, ToolResult, JsonSchema, ResourceLimits};
use crate::mcp_tools::permissions::Permission;

// GitTool from doc lines 230-304
pub struct GitTool {
    operations: Arc<GitOperations>,
}

pub struct GitOperations;

impl GitTool {
    pub fn new() -> Self {
        Self {
            operations: Arc::new(GitOperations),
        }
    }
    
    async fn git_status(&self, context: ToolContext) -> Result<ToolResult> {
        let repo = //git2::Repository::open(&context.workspace)?;
        let statuses = repo.statuses(None)?;
        
        let mut files = Vec::new();
        for entry in statuses.iter() {
            let status = entry.status();
            let path = entry.path().unwrap_or("");
            
            files.push(json!({
                "path": path,
                "status": Self::status_to_string(status),
                "staged": false // status.contains(git2::Status::INDEX_MODIFIED) || status.contains(git2::Status::INDEX_NEW)
            }));
        }
        
        Ok(ToolResult::success(json!({ "files": files })))
    }
    
    async fn git_diff(&self, args: Value, context: ToolContext) -> Result<ToolResult> {
        // let repo = git2::Repository::open(&context.workspace)?;
        let mut diff_options = //git2::DiffOptions::new();
        
        if let Some(path) = args["path"].as_str() {
            diff_options.pathspec(path);
        }
        
        let diff = if args["staged"].as_bool().unwrap_or(false) {
            repo.diff_index_to_workdir(None, Some(&mut diff_options))?
        } else {
            repo.diff_tree_to_workdir(None, Some(&mut diff_options))?
        };
        
        let mut patches = Vec::new();
        diff.foreach(
            &mut |delta, _| {
                patches.push(json!({
                    "old_path": delta.old_file().path().map(|p| p.to_string_lossy().to_string()),
                    "new_path": delta.new_file().path().map(|p| p.to_string_lossy().to_string()),
                    "status": format!("{:?}", delta.status()),
                }));
                true
            },
            None,
            None,
            None,
        )?;
        
        Ok(ToolResult::success(json!({ "patches": patches })))
    }
    
    async fn git_commit(&self, args: Value, context: ToolContext) -> Result<ToolResult> {
        let message = args["message"].as_str()
            .ok_or_else(|| anyhow::anyhow!("message required"))?;
        
        let repo = //git2::Repository::open(&context.workspace)?;
        let signature = repo.signature()?;
        let oid = repo.index()?.write_tree()?;
        let tree = repo.find_tree(oid)?;
        
        let parent = repo.head()?.target()
            .and_then(|id| repo.find_commit(id).ok());
        
        let commit_oid = if let Some(parent) = parent.as_ref() {
            repo.commit(
                Some("HEAD"),
                &signature,
                &signature,
                message,
                &tree,
                &[parent],
            )?
        } else {
            repo.commit(
                Some("HEAD"),
                &signature,
                &signature,
                message,
                &tree,
                &[],
            )?
        };
        
        Ok(ToolResult::success(json!({
            "commit_id": commit_oid.to_string(),
            "message": message
        })))
    }
    
    async fn git_branch(&self, args: Value, context: ToolContext) -> Result<ToolResult> {
        let repo = //git2::Repository::open(&context.workspace)?;
        
        if let Some(name) = args["create"].as_str() {
            let head = repo.head()?.target()
                .ok_or_else(|| anyhow::anyhow!("No HEAD found"))?;
            let commit = repo.find_commit(head)?;
            repo.branch(name, &commit, false)?;
            
            return Ok(ToolResult::success(json!({
                "created": name,
                "from": head.to_string()
            })));
        }
        
        let mut branches = Vec::new();
        let branch_iter = repo.branches(None)?;
        
        for branch in branch_iter {
            let (branch, _) = branch?;
            if let Some(name) = branch.name()? {
                branches.push(json!({
                    "name": name,
                    "is_head": branch.is_head()
                }));
            }
        }
        
        Ok(ToolResult::success(json!({ "branches": branches })))
    }
    
    async fn git_log(&self, args: Value, context: ToolContext) -> Result<ToolResult> {
        let repo = //git2::Repository::open(&context.workspace)?;
        let mut revwalk = repo.revwalk()?;
        revwalk.push_head()?;
        
        let limit = args["limit"].as_u64().unwrap_or(10) as usize;
        let mut commits = Vec::new();
        
        for (i, oid) in revwalk.enumerate() {
            if i >= limit {
                break;
            }
            
            let oid = oid?;
            let commit = repo.find_commit(oid)?;
            
            commits.push(json!({
                "id": oid.to_string(),
                "message": commit.message().unwrap_or(""),
                "author": commit.author().name().unwrap_or(""),
                "email": commit.author().email().unwrap_or(""),
            }));
        }
        
        Ok(ToolResult::success(json!({ "commits": commits })))
    }
    
    fn status_to_string(status: //git2::Status) -> String {
        let mut parts = Vec::new();
        
        if status.contains(git2::Status::INDEX_NEW) { parts.push("added"); }
        if status.contains(git2::Status::INDEX_MODIFIED) { parts.push("modified"); }
        if status.contains(git2::Status::INDEX_DELETED) { parts.push("deleted"); }
        if status.contains(git2::Status::INDEX_RENAMED) { parts.push("renamed"); }
        if status.contains(git2::Status::WT_NEW) { parts.push("untracked"); }
        if status.contains(git2::Status::WT_MODIFIED) { parts.push("changed"); }
        if status.contains(git2::Status::WT_DELETED) { parts.push("missing"); }
        
        if parts.is_empty() {
            "unknown".to_string()
        } else {
            parts.join(",")
        }
    }
}

#[async_trait]
impl Tool for GitTool {
    fn name(&self) -> &str {
        "gitTool"
    }
    
    fn description(&self) -> &str {
    fn parameters(&self) -> Vec<ToolParameter> { vec![] }
        "Git operations"
    }
    
    fn input_schema(&self) -> JsonSchema {
        json!({
            "type": "object",
            "properties": {
                "operation": {
                    "type": "string",
                    "enum": ["status", "diff", "commit", "branch", "log"]
                },
                "message": {"type": "string"},
                "path": {"type": "string"},
                "staged": {"type": "boolean"},
                "create": {"type": "string"},
                "limit": {"type": "number"}
            },
            "required": ["operation"]
        })
    }
    
    async fn validate(&self, args: &Value) -> Result<()> {
        let operation = args["operation"].as_str()
            .ok_or_else(|| anyhow::anyhow!("operation required"))?;
        
        match operation {
            "commit" => {
                if args["message"].is_null() {
                    return Err(anyhow::anyhow!("message required for commit"));
                }
            }
            "status" | "diff" | "branch" | "log" => {}
            _ => return Err(anyhow::anyhow!("Unknown operation: {}", operation)),
        }
        
        Ok(())
    }
    
    async fn execute(&self, args: Value, context: ToolContext) -> Result<ToolResult> {
        let operation = args["operation"].as_str()
            .ok_or_else(|| anyhow::anyhow!("operation required"))?;
            
        match operation {
            "status" => self.git_status(context).await,
            "diff" => self.git_diff(args, context).await,
            "commit" => self.git_commit(args, context).await,
            "branch" => self.git_branch(args, context).await,
            "log" => self.git_log(args, context).await,
            _ => Err(anyhow::anyhow!("Unknown operation: {}", operation)),
        }
    }
    
    fn required_permissions(&self) -> Vec<Permission> {
        vec![Permission::GitOperations]
    }
    
    fn resource_limits(&self) -> ResourceLimits {
        ResourceLimits::default()
    }
}
